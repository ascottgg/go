Реприоритезация реализована в коде. Также есть вариант реализации на уровне процедур в PostgreSQL с использованием триггера. В таком случае, каждый раз когда по роутам /good/update и /good/repriotize будет изменяться значение приоритета, а значения приоритета последующих строк пересчитаются. Сейчас приоритеты перерасчитываются только по роуту /good/reprioritize. Возможная реализация такой процедуры update_subsequent_priority() закомментирована в миграции.

Логирование в ClickHouse в таблицу logs через NATS реализовано с использованием таблицы nats_logs (NATS Engine) и материализованное представление logs_to_main. (подробнее в файлах миграции)

Установка приоритета по формуле "макс приоритет в таблице + 1" реализована в коде. Продублировал возможную реализацию на уровне процедур в PostgreSQL.

При отказе в работе Redis'а как возможное решение можно возвращать 500 ошибку по GET роуту, чтобы не получить каскадный сбой и не перегрузить БД COUNT запросами для получения общего количесвта записей и количества removed записей. Как вариант, можно хранить count и removed_count в отдельной таблице в базе. В то же самое время другие эндпоинты будут исправно работать.

При проблемах доступа к PosgreSQL:
```
CREATE USER "user" WITH PASSWORD 'password'
GRANT ALL PRIVILEGES ON SCHEMA public TO "user";
```

Запустить инфру:
```
make docker-up
```

Запустить миграции:
```
make migrate
```

Не хватило времени реализовать:
- Сткрутурировать валидацию в хендлерах: написать валидатор, читающий тег required структур входящих параметров, проверяющий значение на нулевое значение типа и выводящий соответсвующую ошибку.
- Структурировать логику отправки ответов из хендлеров для ликвидации дублирующегося кода.
- Обеспечить отказоустойчивую отправку логов в брокер: использовать для это retries и гарантировать уникальность на уровне NATS JetStream.
- Обдумать более производительные подходы обеспечивающие наибольшую согласованность данных при реприоритезации товаров.
